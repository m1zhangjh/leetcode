20170720
1. Two Sum
	unordered_map:	hash table
	map:	balanced tree/ red black tree
	
	unordered_map<,> hash;
	hash.find() == hash.end() // if not found
	
	CONSIDER the difference between index and the returned position.
	
	
	
						   | map              | unordered_map
	---------------------------------------------------------
	element ordering       | strict weak      | n/a 
						   |                  |
	common implementation  | balanced tree    | hash table
						   | or red-black tree|  
						   |                  |
	search time            | log(n)           | O(1) if there are no hash collisions
						   |                  | Up to O(n) if there are hash collisions 
						   |                  | O(n) when hash is the same for any key
						   |                  |     
	Insertion time         | log(n)+rebalance | Same as search
						   |                  | 
	Deletion time          | log(n)+rebalance | Same as search
						   |                  | 
	needs comparators      | only operator <  | only operator ==
						   |                  |
	needs hash function    | no               | yes
						   |                  |
	common use case        | when good hash is| In most other cases. 
						   | not possible or  | 
						   | too slow. Or when|
						   | order is required| 
						   

20. Valid Parentheses						   
	Return Void
		pop in queue and stack
		pop_back in vector
		pop_back/pop_front in list

	list:
		begin		end
		front		back
		pop_front	pop_back	(return void)
		push_front	push_back
	vector:
		begin		end
		front		back
					pop_back	(return void)
					push_back
	queue:
		front		back
					pop			(return void)
		push
	stack:
		top
		pop						(return void)
		push
		
		
	switch (c) {
		case '(':	break;
		case '[':	break;
		default: ;
	}
	
	
21. Merge Two Sorted Lists
	
	Single Link List Struct
	struct ListNode {
		int val;
		ListNode *next;
	}
	
	Check the head is NULL or not
	
	The result link list head should be initialize
		resHead;
		it;
		list1;
		list2;
		
	Consider recursive for link list
	

53. Maximum Subarray
	dynamic algorithm
	largest sum + contiguous subarray
	-> previous array disadvantage -> reset
	

70. Climbing Stairs
	recursive method -> re-implement in loop
	save time
	
	
101. Symmetric Tree
	Deepth First Search (DFS):
		check
		left
		right
		
	Breadth First Search (BFS):
		queue to store
	
	Instead of check two children of root, push root twice
	
	Recursive:
		right->left child == left->right child
		return (val & r->l & l->r)
	
	
104. Maximum Depth of Binary Tree
	max, min are std functions
		using std function is faster

		
110. Balanced Binary Tree
	abs()	
	return depth, if not balanced -1
	
121. Best Time to Buy and Sell Stock
	The maximal substraction in array
	Each var - the min before it
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		
		
	