20170720
1. Two Sum
	unordered_map:	hash table
	map:	balanced tree/ red black tree
	
	unordered_map<,> hash;
	hash.find() == hash.end() // if not found
	
	CONSIDER the difference between index and the returned position.
	
	
	
						   | map              | unordered_map
	---------------------------------------------------------
	element ordering       | strict weak      | n/a 
						   |                  |
	common implementation  | balanced tree    | hash table
						   | or red-black tree|  
						   |                  |
	search time            | log(n)           | O(1) if there are no hash collisions
						   |                  | Up to O(n) if there are hash collisions 
						   |                  | O(n) when hash is the same for any key
						   |                  |     
	Insertion time         | log(n)+rebalance | Same as search
						   |                  | 
	Deletion time          | log(n)+rebalance | Same as search
						   |                  | 
	needs comparators      | only operator <  | only operator ==
						   |                  |
	needs hash function    | no               | yes
						   |                  |
	common use case        | when good hash is| In most other cases. 
						   | not possible or  | 
						   | too slow. Or when|
						   | order is required| 
						   

20. Valid Parentheses						   
	Return Void
		pop in queue and stack
		pop_back in vector
		pop_back/pop_front in list

	list:
		begin		end
		front		back
		pop_front	pop_back	(return void)
		push_front	push_back
	vector:
		begin		end
		front		back
					pop_back	(return void)
					push_back
	queue:
		front		back
					pop			(return void)
		push
	stack:
		top
		pop						(return void)
		push
		
		
	switch (c) {
		case '(':	break;
		case '[':	break;
		default: ;
	}
	
	
21. Merge Two Sorted Lists
	
	Single Link List Struct
	struct ListNode {
		int val;
		ListNode *next;
	}
	
	Check the head is NULL or not
	
	The result link list head should be initialize
		resHead;
		it;
		list1;
		list2;
		
	Consider recursive for link list
	

53. Maximum Subarray
	dynamic algorithm
	largest sum + contiguous subarray
	-> previous array disadvantage -> reset
	

70. Climbing Stairs
	recursive method -> re-implement in loop
	save time
	
	
101. Symmetric Tree
	Deepth First Search (DFS):
		check
		left
		right
		
	Breadth First Search (BFS):
		queue to store
	
	Instead of check two children of root, push root twice
	
	Recursive:
		right->left child == left->right child
		return (val & r->l & l->r)
	
	
104. Maximum Depth of Binary Tree
	max, min are std functions
		using std function is faster

		
110. Balanced Binary Tree
	abs()	
	return depth, if not balanced -1
	
121. Best Time to Buy and Sell Stock
	The maximal substraction in array
	Each var - the min before it
	
	
136. Single Number
	XOR
	bit operation
	~
	&
	|
	^ XOR
	
	
141. Linked List Cycle
	2x 1x finally meet in a cycle
	Assume cycle is X steps,
	Each iteration, 2x is 1 step faster than 1x.
	After some iterations, 2x is X steps ahead than 1x.
	
	
155. Min Stack
	stack do not have clear()
		only push pop top empty size
	class 
		private variables are at bottom
		
	For stack,
		The min/max is fixed when each element pushed 
		
		
160. Intersection of Two Linked Lists
	How to reach the same node at the same time.
	The lengths of two linked lists are different,
	However, if two walkers go through one list, then back to another list,
	Then the length before two walkers reach the intersection node is the same time.

	Consider one list is NULL
	recursive is wrong, because two linked listed have a lot of common nodes
	
	
169. Majority Element
	nth_element (nums.begin(), nums.begin()+x, nums.end() );
	count(nums.begin(), nums.end(), x);
	count(nums.begin()+s, nums.begin()+e+1, x);
	
	vote
	bit
	
	
198. House Robber
	recursive is time limit exceeded
	a: is only add last even
	b: is only add last odd
	
	
206. Reverse Linked List
	The broken part is needed tmp.
	tmp: next
	
	
848. Shifting Letters
	String char, larger than 26, use (S[i] - 'a' + shift) % 26 + 'a'
		String[i] = (String[i] - 'a' + shift) % 26 + 'a'
	
	for loop, second is condition that: if it fits condition, continue
		for (int index = S.size() - 1; index >= 0; index--)
	
	
	
	
	
	
	
		
		
	