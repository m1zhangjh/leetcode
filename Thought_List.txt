/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
	ListNode* inverse(ListNode* head) {
        ListNode* prev = NULL;
        ListNode* cur = head;
        ListNode* temp = NULL;
        while (cur != NULL) {
            temp = cur->next;
            cur->next = prev;
            prev = cur;
            cur = temp;
        }
        return prev;
    }

NC33 merge two sorted linked list
	Check NULL
		return non-NULL
	Check comparison
		small next = recursive
		return small
NC66 两个链表的第一个公共结点
	Suffix is the same
	Size Difference, to find compare position
	
NC40 两个链表生成相加链表
	if (resHead == NULL) {
		resHead = resTempNew;
		res = resTempNew;
	}
	else {
		res->next = resTempNew;
		res = res->next;
	}
NC96 判断一个链表是否为回文结构 (Palindrome)
	Half, inverse, compare
NC133 链表的奇偶重排
	if (oddIndex->next == NULL)
		oddIndex->next = evenHead;
	Must connect through the last node->next, not the last NULL